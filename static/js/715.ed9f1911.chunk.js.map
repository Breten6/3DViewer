{"version":3,"file":"static/js/715.ed9f1911.chunk.js","mappings":"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","sources":["../node_modules/lzfjs/lzf.js","../webpack/bootstrap","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/hasOwnProperty shorthand","fileParser.worker.js"],"sourcesContent":["/**\r\n * LZF compression/decompression module. Ported from the C\r\n * implementation of liblzf, specfically lzf_c.c and lzf_d.c\r\n * @license BSD-2-Clause\r\n */\r\n\r\n \"use strict\";\r\n\r\n/**\r\n * Decompress a TypedArray (in browser) or Buffer (in node)\r\n * containing LZF compressed data.\r\n * @param {(ArrayBuffer|TypedArray|Buffer)} data - the data to be decompressed\r\n * @returns {(Uint8Array|Buffer)} - decompressed data\r\n */\r\nfunction decompress(data) {\r\n    var input = new Uint8Array(data);\r\n    var output = [];\r\n\r\n    var ip = 0;\r\n    var op = 0;\r\n\r\n    do {\r\n        var ctrl = input[ip++];\r\n\r\n        if (ctrl < (1 << 5)) { /* literal run */\r\n            ctrl++;\r\n\r\n            if (ip + ctrl > input.length) {\r\n                throw new Error('Invalid input'); \r\n            }\r\n\r\n            while (ctrl--) {\r\n                output[op++] = input[ip++];\r\n            }\r\n        } else { /* back reference */\r\n            var len = ctrl >> 5;\r\n            var ref =  op - ((ctrl & 0x1f) << 8) - 1;\r\n\r\n            if (ip >= input.length) {\r\n                throw new Error('Invalid input');\r\n            }\r\n\r\n            if (len == 7) {\r\n                len += input[ip++];\r\n\r\n                if (ip >= input.length) {\r\n                    throw new Error('Invalid input');\r\n                }\r\n            }\r\n\r\n            ref -= input[ip++];\r\n\r\n            if (ref < 0) {\r\n                throw new Error('Invalid input');\r\n            }\r\n\r\n            len += 2;\r\n\r\n            do {\r\n                output[op++] = output[ref++];\r\n            } while (--len);\r\n        }\r\n    } while (ip < input.length);\r\n\r\n    // Return a Buffer if it exists (say in node), otherwise just\r\n    // use a normal Uint8Array.\r\n    if (typeof Buffer !== 'undefined') {\r\n        return new Buffer(output);\r\n    } else {\r\n        var res = new Uint8Array(output.length);\r\n        res.set(output);\r\n        return res;\r\n    }\r\n}\r\n\r\n/**\r\n * Compress a buffer containing some data\r\n * @param {(ArrayBuffer|TypedArray|Buffer)} data - the data to be compressed\r\n * @returns {(Uint8Array|Buffer)} - compressed data\r\n */\r\nfunction compress(data) {\r\n    var HLOG = 16;\r\n    var HSIZE = (1 << HLOG);\r\n    var LZF_MAX_OFF = (1 << 13);\r\n    var LZF_MAX_REF = ((1 << 8) + (1 << 3));\r\n    var LZF_MAX_LIT = (1 <<  5);\r\n\r\n    function FRST(data, p) {\r\n        return (((data[p]) << 8) | data[p+1]);\r\n    }\r\n\r\n    function NEXT(v, data, p) {\r\n        return (((v) << 8) | data[p+2]);\r\n    }\r\n\r\n    function IDX(h) {\r\n        return (((h * 0x1e35a7bd) >> (32 - HLOG - 8)) & (HSIZE - 1));\r\n    }\r\n\r\n    var input = new Uint8Array(data);\r\n    var output = [];\r\n    var htab = new Uint32Array(HSIZE);\r\n\r\n    var in_end = input.length, ip = 0, hval = FRST(input, ip);\r\n    var op = 1, lit = 0; /* start run */\r\n\r\n    while (ip < in_end - 2) {\r\n        hval = NEXT(hval, data, ip);\r\n        var hslot = IDX(hval);\r\n        var ref = htab[hslot];\r\n        htab[hslot] = ip;\r\n\r\n        var off;\r\n\r\n        if (ref < ip /* the next test will actually take care of this, but this is faster */\r\n            && (off = ip - ref - 1) < LZF_MAX_OFF\r\n            && ref > 0\r\n            && input[ref + 2] == input[ip + 2]\r\n            && input[ref + 1] == input[ip + 1]\r\n            && input[ref] == input[ip]\r\n        ) {\r\n            /* match found at *ref++ */\r\n            var len = 2;\r\n            var maxlen = in_end - ip - len;\r\n            maxlen = maxlen > LZF_MAX_REF ? LZF_MAX_REF : maxlen;\r\n\r\n            output[op - lit - 1] = (lit - 1) & 255; /* stop run */\r\n            if (lit == 0) {\r\n                op -= 1; /* undo run if length is zero */\r\n            }\r\n\r\n            do {\r\n                len++;\r\n            }\r\n            while (len < maxlen && input[ref + len] == input[ip + len]);\r\n\r\n            len -= 2; /* len is now #octets - 1 */\r\n            ip++;\r\n\r\n            if (len < 7) {\r\n                output[op++] = ((off >> 8) + (len << 5)) & 255;\r\n            } else {\r\n                output[op++] = ((off >> 8) + (7 << 5)) & 255;\r\n                output[op++] = (len - 7) & 255;\r\n            }\r\n\r\n            output[op++] = off & 255;\r\n\r\n            lit = 0; op++; /* start run */\r\n\r\n            ip += len + 1;\r\n\r\n            if (ip >= in_end - 2) {\r\n                break;\r\n            }\r\n\r\n            --ip;\r\n            --ip;\r\n            hval = FRST(input, ip);\r\n\r\n            hval = NEXT(hval, input, ip);\r\n            htab[IDX(hval)] = ip++;\r\n\r\n            hval = NEXT(hval, input, ip);\r\n            htab[IDX(hval)] = ip++;\r\n        } else {\r\n            lit++;\r\n            output[op++] = input[ip++];\r\n\r\n            if (lit == LZF_MAX_LIT) {\r\n                output[op - lit - 1] = (lit - 1) & 255; /* stop run */\r\n                lit = 0; op++; /* start run */\r\n            }\r\n        }\r\n    }\r\n\r\n    while (ip < in_end) {\r\n        lit++;\r\n        output[op++] = input[ip++];\r\n\r\n        if (lit == LZF_MAX_LIT) {\r\n            output[op - lit - 1] = (lit - 1) & 255; /* stop run */\r\n            lit = 0; op++; /* start run */\r\n        }\r\n    }\r\n\r\n    if (lit != 0) {\r\n        output[op - lit - 1] = (lit - 1) & 255; /* stop run */\r\n    }\r\n\r\n    // Return a Buffer if it exists (say in node), otherwise just\r\n    // use a normal Uint8Array.\r\n    if (typeof Buffer !== 'undefined') {\r\n        return new Buffer(output);\r\n    } else {\r\n        var res = new Uint8Array(output.length);\r\n        res.set(output);\r\n        return res;\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    decompress: decompress,\r\n    compress: compress\r\n};\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// src/fileParser.worker.js\n/* eslint-disable no-restricted-globals */\nimport lzf from 'lzfjs';\n\nself.onmessage = function (e) {\n  const { fileType, arrayBuffer, text, fileName, size } = e.data;\n  console.log('Worker received message:', e.data);\n\n  try {\n    let result = null;\n\n    if (fileType === '.pcd' && arrayBuffer) {\n      result = parsePCD(arrayBuffer, fileName, size);\n    } else if (fileType === '.xyz' && text) {\n      result = parseXYZ(text, fileName, size);\n    } else if ((fileType === '.geojson' || fileType === '.json') && text) {\n      result = parseGeoJSON(text, fileName, size);\n    } else {\n      throw new Error(`Unsupported file type or data mismatch: ${fileType}`);\n    }\n\n    // success\n    self.postMessage({ success: true, data: result });\n  } catch (error) {\n    console.error('Worker error:', error);\n    self.postMessage({ success: false, error: error.message });\n  }\n};\n\n// parseXYZ - send progress\nfunction parseXYZ(xyzText, fileName, size) {\n  console.log('Parsing .xyz file');\n  const lines = xyzText.split(/\\r?\\n/).filter(line => line.trim() !== '');\n  const points = [];\n  let invalidLines = 0;\n\n  const total = lines.length;\n  lines.forEach((line, index) => {\n    if (index % 5000 === 0) {\n      const percent = Math.floor((index / total) * 100);\n      self.postMessage({ progress: percent });\n    }\n\n    const parts = line.trim().split(/[\\s,]+/);\n    if (parts.length < 3) {\n      invalidLines++;\n      return;\n    }\n    const [xStr, yStr, zStr] = parts;\n    const x = parseFloat(xStr);\n    const y = parseFloat(yStr);\n    const z = parseFloat(zStr);\n    if (!isFinite(x) || !isFinite(y) || !isFinite(z)) {\n      invalidLines++;\n      return;\n    }\n    points.push({ x, y, z });\n  });\n\n  // Parsing complete\n  self.postMessage({ progress: 100 });\n\n  // Calculate bounding box\n  let minX = Infinity, minY = Infinity, minZ = Infinity;\n  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n  \n  points.forEach(p => {\n    if (p.x < minX) minX = p.x;\n    if (p.y < minY) minY = p.y;\n    if (p.z < minZ) minZ = p.z;\n    if (p.x > maxX) maxX = p.x;\n    if (p.y > maxY) maxY = p.y;\n    if (p.z > maxZ) maxZ = p.z;\n  });\n\n  return {\n    type: 'xyz',\n    fileName,\n    size,\n    pointCount: points.length,\n    boundingBox: { minX, minY, minZ, maxX, maxY, maxZ },\n    points,\n    invalidLines,\n  };\n}\n\nfunction parseGeoJSON(jsonText, fileName, size) {\n  console.log('Parsing GeoJSON');\n  const geoJSON = JSON.parse(jsonText);\n  if (!geoJSON.type || (geoJSON.type !== 'FeatureCollection' && geoJSON.type !== 'Feature')) {\n    throw new Error('Invalid GeoJSON format');\n  }\n  return {\n    type: 'geojson',\n    fileName,\n    size,\n    geoJSON,\n  };\n}\n\n// ============ parsePCD =============\nfunction parsePCD(arrayBuffer, fileName, size) {\n  console.log('Parsing .pcd file with ArrayBuffer');\n\n  const textDecoder = new TextDecoder();\n  const headerText = textDecoder.decode(arrayBuffer);\n  const lines = headerText.split(/\\r?\\n/);\n  const header = {};\n  let dataStartLineIndex = 0;\n\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i].trim();\n    if (!line) continue;\n    if (line.startsWith('DATA')) {\n      const parts = line.split(/\\s+/);\n      header.DATA = parts[1] || 'ascii';\n      dataStartLineIndex = i + 1;\n      break;\n    }\n    const [key, ...rest] = line.split(/\\s+/);\n    header[key] = rest.join(' ');\n  }\n  if (!header.DATA) {\n    header.DATA = 'ascii';\n  }\n\n  const dataFormat = header.DATA.toLowerCase();\n  const fields = (header.FIELDS || '').split(/\\s+/);\n  const sizes = (header.SIZE || '').split(/\\s+/).map(Number);\n  const types = (header.TYPE || '').split(/\\s+/);\n  const counts = (header.COUNT || '').split(/\\s+/).map(Number);\n  const numPoints = parseInt(header.POINTS || '0', 10);\n\n  // Calculate header byte size\n  let headerByteSize = 0;\n  {\n    let linesCount = 0;\n    let byteCursor = 0;\n    while (linesCount < dataStartLineIndex && byteCursor < headerText.length) {\n      if (headerText[byteCursor] === '\\n') {\n        linesCount++;\n      }\n      byteCursor++;\n    }\n    headerByteSize = byteCursor;\n  }\n\n  let points = [];\n  let invalidLines = 0;\n  if (dataFormat === 'ascii') {\n    const result = parsePCD_ASCII(arrayBuffer, headerByteSize, numPoints);\n    points = result.points;\n    invalidLines = result.invalidLines;\n  } else if (dataFormat === 'binary') {\n    points = parsePCD_Binary(arrayBuffer, headerByteSize, numPoints, fields, sizes, types, counts);\n    // No invalid lines tracking in binary\n  } else if (dataFormat === 'binary_compressed') {\n    points = parsePCD_BinaryCompressed_LZF(arrayBuffer, headerByteSize, numPoints, fields, sizes, types, counts);\n    // No invalid lines tracking in binary_compressed\n  } else {\n    throw new Error(`Unsupported DATA format: ${header.DATA}`);\n  }\n\n  // Calculate bounding box\n  let minX = Infinity, minY = Infinity, minZ = Infinity;\n  let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n  for (const p of points) {\n    if (p.x < minX) minX = p.x;\n    if (p.y < minY) minY = p.y;\n    if (p.z < minZ) minZ = p.z;\n    if (p.x > maxX) maxX = p.x;\n    if (p.y > maxY) maxY = p.y;\n    if (p.z > maxZ) maxZ = p.z;\n  }\n\n  return {\n    type: 'pcd',\n    fileName,\n    size,\n    pointCount: points.length,\n    boundingBox: { minX, minY, minZ, maxX, maxY, maxZ },\n    points,\n    invalidLines, // Note: invalidLines is only tracked for ascii\n  };\n}\n\n//parsePCD_ASCII - send progress\nfunction parsePCD_ASCII(arrayBuffer, offset, numPoints) {\n  const textDecoder = new TextDecoder();\n  const asciiText = textDecoder.decode(arrayBuffer.slice(offset));\n  const lines = asciiText.split(/\\r?\\n/).filter(line => line.trim() !== '');\n  const points = [];\n  let invalidLines = 0;\n  const total = lines.length;\n\n  for (let i = 0; i < lines.length; i++) {\n    // Send progress\n    if (i % 5000 === 0) {\n      const percent = Math.floor((i / total) * 100);\n      self.postMessage({ progress: percent });\n    }\n\n    const vals = lines[i].trim().split(/\\s+/).map(parseFloat);\n    if (vals.length >= 3) {\n      const x = vals[0], y = vals[1], z = vals[2];\n      if (isFinite(x) && isFinite(y) && isFinite(z)) {\n        points.push({ x, y, z });\n      } else {\n        invalidLines++;\n      }\n    } else {\n      invalidLines++;\n    }\n  }\n\n  // Parsing complete\n  self.postMessage({ progress: 100 });\n\n  return {\n    points,\n    invalidLines,\n  };\n}\n\nfunction parsePCD_Binary(arrayBuffer, offset, numPoints, fields, sizes, types, counts) {\n  const dataView = new DataView(arrayBuffer, offset);\n  \n  // Correctly calculate pointStep as sum of size * count for each field\n  let pointStep = 0;\n  const fieldOffsets = []; // To store offset for each field\n  for (let f = 0; f < fields.length; f++) {\n    fieldOffsets.push(pointStep);\n    pointStep += sizes[f] * counts[f];\n  }\n\n  const points = [];\n  const totalPoints = numPoints;\n  \n  for (let i = 0; i < totalPoints; i++) {\n    // Send progress\n    if (i % 5000 === 0) {\n      const percent = Math.floor((i / totalPoints) * 100);\n      self.postMessage({ progress: percent });\n    }\n\n    const point = {};\n    for (let f = 0; f < fields.length; f++) {\n      const fieldName = fields[f];\n      const type = types[f];\n      const size = sizes[f];\n      const count = counts[f];\n      const byteOffset = i * pointStep + fieldOffsets[f];\n\n      // Only process x, y, z\n      if (fieldName === 'x' || fieldName === 'y' || fieldName === 'z') {\n        if (type === 'F' && size === 4 && count === 1) {\n          point[fieldName] = dataView.getFloat32(byteOffset, true);\n        } else if (type === 'I' && size === 4 && count === 1) {\n          point[fieldName] = dataView.getInt32(byteOffset, true);\n        } else if (type === 'U' && size === 4 && count === 1) {\n          point[fieldName] = dataView.getUint32(byteOffset, true);\n        } else {\n          point[fieldName] = null; // 或其他默认值\n        }\n      }\n      // Skip other fields (e.g., '_')\n    }\n    points.push(point);\n  }\n\n  self.postMessage({ progress: 100 });\n  return points;\n}\n\nfunction parsePCD_BinaryCompressed_LZF(arrayBuffer, offset, numPoints, fields, sizes, types, counts) {\n  const view = new DataView(arrayBuffer, offset);\n  if (view.byteLength < 8) {\n    throw new Error('Not enough data to read compressedSize/uncompressedSize.');\n  }\n\n  const compressedSize = view.getUint32(0, true);\n  const uncompressedSize = view.getUint32(4, true);\n\n  if (view.byteLength < 8 + compressedSize) {\n    throw new Error('Buffer is too short for the indicated compressedSize');\n  }\n\n  const compressedData = new Uint8Array(arrayBuffer, offset + 8, compressedSize);\n\n  let decompressed;\n  try {\n    decompressed = lzf.decompress(compressedData, uncompressedSize);\n  } catch (err) {\n    throw new Error('LZFJS decompress error: ' + err.message);\n  }\n\n  if (decompressed.length !== uncompressedSize) {\n    console.warn(`LZF: mismatch uncompressedSize => got=${decompressed.length}, expected=${uncompressedSize}`);\n  }\n\n  // SoA to AoS\n  const { points } = reorderSoAToAoS_withProgress(decompressed, numPoints, fields, sizes, types);\n  self.postMessage({ progress: 100 });\n  return points;\n}\n\n// =========== reorderSoAToAoS_withProgress ===========\nfunction reorderSoAToAoS_withProgress(decompressed, numPoints, fields, sizes, types) {\n  const totalFields = fields.length;\n  const pointStep = sizes.reduce((sum, s) => sum + s, 0); // Assuming SoA\n\n  const dataView = new DataView(decompressed.buffer, decompressed.byteOffset, decompressed.byteLength);\n\n  const fieldOffsets = [];\n  {\n    let offset = 0;\n    for (let f = 0; f < totalFields; f++) {\n      fieldOffsets.push(offset);\n      offset += sizes[f] * numPoints; // SoA\n    }\n  }\n\n  const points = [];\n  for (let i = 0; i < numPoints; i++) {\n    // Progress\n    if (i % 5000 === 0) {\n      const p = Math.floor((i / numPoints) * 100);\n      self.postMessage({ progress: p });\n    }\n\n    const point = {};\n    for (let f = 0; f < totalFields; f++) {\n      const fName = fields[f];\n      const fType = types[f];\n      const fSize = sizes[f];\n      const byteOffset = fieldOffsets[f] + i * fSize;\n\n      // Only process x, y, z\n      if (fName === 'x' || fName === 'y' || fName === 'z') {\n        if (fType === 'F' && fSize === 4) {\n          point[fName] = dataView.getFloat32(byteOffset, true);\n        } else if (fType === 'I' && fSize === 4) {\n          point[fName] = dataView.getInt32(byteOffset, true);\n        } else if (fType === 'U' && fSize === 4) {\n          point[fName] = dataView.getUint32(byteOffset, true);\n        } else {\n          point[fName] = null;\n        }\n      }\n      // Skip other fields\n    }\n    points.push(point);\n  }\n\n  const validPoints = points.filter(p => \n    isFinite(p.x) && isFinite(p.y) && isFinite(p.z)\n  );\n  return { points: validPoints };\n}\n"],"names":["module","exports","decompress","data","input","Uint8Array","output","ip","op","ctrl","length","Error","len","ref","Buffer","res","set","compress","FRST","p","NEXT","v","IDX","h","HSIZE","htab","Uint32Array","in_end","hval","lit","off","hslot","maxlen","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","n","getter","__esModule","d","a","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","self","onmessage","e","fileType","arrayBuffer","text","fileName","size","console","log","result","headerText","TextDecoder","decode","lines","split","header","dataStartLineIndex","i","line","trim","startsWith","parts","DATA","rest","join","dataFormat","toLowerCase","fields","FIELDS","sizes","SIZE","map","Number","types","TYPE","counts","COUNT","numPoints","parseInt","POINTS","headerByteSize","linesCount","byteCursor","points","invalidLines","offset","textDecoder","asciiText","slice","filter","total","percent","Math","floor","postMessage","progress","vals","parseFloat","x","y","z","isFinite","push","parsePCD_ASCII","dataView","DataView","pointStep","fieldOffsets","f","totalPoints","point","fieldName","type","count","byteOffset","getFloat32","getInt32","getUint32","parsePCD_Binary","concat","view","byteLength","compressedSize","uncompressedSize","compressedData","decompressed","lzf","err","message","warn","totalFields","reduce","sum","s","buffer","fName","fType","fSize","validPoints","reorderSoAToAoS_withProgress","parsePCD_BinaryCompressed_LZF","minX","Infinity","minY","minZ","maxX","maxY","maxZ","pointCount","boundingBox","parsePCD","xyzText","forEach","index","xStr","yStr","zStr","parseXYZ","jsonText","geoJSON","JSON","parse","parseGeoJSON","success","error"],"sourceRoot":""}